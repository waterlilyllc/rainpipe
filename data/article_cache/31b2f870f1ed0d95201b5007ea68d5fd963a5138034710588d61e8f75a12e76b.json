{
  "url": "https://zenn.dev/tacoms/articles/552140c84aaefa",
  "content": {
    "text": "Claude CodeのSub agentsでコンテキスト枯渇問題をサクッと解決できたはなし 旧tacomsテックブログ 旧tacomsテックブログ Publicationへの投稿 🤖 Claude CodeのSub agentsでコンテキスト枯渇問題をサクッと解決できたはなし shinpr 2025/07/25 に公開 2025/10/11 LLM Claude Claude Code zennfes2025ai tech Claude CodeのSub agents（サブエージェント）という機能が今自分が困っているユースケースの改善に役立ちそうだったので使ってみました。 https://docs.anthropic.com/en/docs/claude-code/sub-agents 結論から書くと、1-2時間くらいでサクッと作った割には期待された効果を発揮できました。便利ですね。当面積極活用していきたいと感じました。 開発において定型的な作業は多く発生します。これまではそれをルールファイルに記載して制御していましたが、Sub agents に適切に分離することで、責務が明確になり、不要なルールを読み込まなくて良くなり、エージェント全体を通してルールと責務が整備できるようになったなと感じました。 Sub agents とは？ Create and use specialized AI sub agents in Claude Code for task-specific workflows and improved context management. Custom sub agents in Claude Code are specialized AI assistants that can be invoked to handle specific types of tasks. They enable more efficient problem-solving by providing task-specific configurations with customized system prompts, tools and a separate context window. 要は、Claude Codeで特定タスク用の専門AIアシスタントを作って、効率的な問題解決とコンテキスト管理ができる機能です。 .claude/agents にフロントマター付きのMarkdownファイルを作成することで、Claude CodeがSub agents を認識し、活用してくれるようになります。 設定されているかどうかは、 /agents を実行すれば確認することができます。 複雑な実装をすることなく、これまでルールを書いていたような書き味でエージェントの責務を設定すればいいだけなので、比較的容易に既存プロジェクトにも導入可能なのではないかと感じました。 どういう課題を感じていたか 背景として、私は社内のチャットボットをVibe Codingで作成しています。 このチャットボットはTypeScriptで書かれた、Geminiを活用したAIチャットボットです。 いくつかの機能があり、中でもDeepResearchもどきの機能が複雑性が高い割には精度が出にくく苦戦している機能になります。 都合2回ほど大規模なリファクタリング・リアーキをしていましたが、それでも精度が出ず、直近1週間ほどかけて、3度目のリアーキに向き合っていました。 Sub agents が出るまでのリアーキの進め方は以下の通りです。 実際の出力とログを元に、現状の課題の伝達（私 -&gt; AI） 要因を特定し、改善のための計画を考える（AI） 改善計画についてディスカッションし、実装方針をADR/Design Docとして書き起こす（私・AI -&gt; AI） ルール、設計ドキュメントを元に、実装計画を立案（AI） 付き添いをしながら、計画を順次実行していく（私・AI） ADR/Design Docを作成すること、実装時にADR/Design Docを読み込むこと、計画を立て作業を進めることは既存のルールで実現していました。 本来的には計画の実行についても自律的に進めてほしいところですが、ここにこのプロジェクトを進める上で私の頭を悩ませる課題があったのです。 それは、コンテキストの枯渇による auto-compact です。 auto-compactの課題 計画に沿って実装し、最後に品質チェックを行い、コミットするまでが一連の作業です。 この「品質チェック」のボリュームが大きく、実装品質がそこそこだった場合にコンテキストウィンドウを食い潰す要因になっていました。 Biomeによるチェック、改善 Lintエラーの解消 フォーマットチェック、改善 未使用エクスポート検出、改善 循環依存チェック、改善 TypeScriptビルドエラーの改善（型エラーの改善） テストの実行とカバレッジの計測（70%目標） 加えて、ルールを整備しており、CLAUDE.md以外にも7つのルールファイルが存在し、ルール逸脱による課題の方が大きかった都合で最初に全てのルールを読み込む運用にしています。 このような事情があり、1つのタスクを終える前にauto-compactが走り、復帰後のコンテキストが欠落した状態で品質チェックが継続され、主にテストの品質が低下傾向にあるという課題が発生していました。 重複したテストが作成されていたり、モックやヘルパーを活用していなかったり、そもそもテストをパスさせられなくなってしまう事象がauto-compact後には頻発します。 おそらくルールファイルの読み込みがなされないことと、直前の作業の引き継ぎが甘いことによる、生成精度の低下が発生していそうな感覚です。 Sub agentsの導入でどう変わったか？ まず、以下の Sub agents を作成しました。 quality-checker : 品質チェックを行うsub-agent task-decomposer : 計画ファイルを、1コミットの粒度かつコンテキストが枯渇しないだろう（ここは経験則）範囲でのタスクに分解するsub-agent task-executor : タスクを実行し、進捗管理をタスクファイルで行うsub-agent これらの Sub agents を 付き添いをしながら、計画を順次実行していく（私・AI） このフェーズに投入し、auto-compactを制御しながらタスクを完遂させようというのが今回の取り組みです。 具体的には、以下のようなフローになります。 作業計画書を task-decomposerで分解する 分解されたタスクをtask-executorで実行し、実行が終わったらquality-checkerで品質チェックを行う これをタスクファイルがなくなるまで繰り返す task-decomposerは、計画ファイル（リポジトリ内の docs/plans/xxxx.md ）を参照し、タスクファイルを生成します。 docs/plans/task",
    "extracted_at": "2025-11-13T15:31:22+09:00"
  },
  "cached_at": "2025-11-13T15:31:22+09:00"
}